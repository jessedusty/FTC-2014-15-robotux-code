#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSPB,                sensorI2CCustom9V)
#pragma config(Sensor, S4,     HTIRS2,              sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rollerMotor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     flapTrackMotor, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     leftDriveR,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rightDriveF,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     rightDriveR,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     leftDriveF,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     liftMotor2,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     liftMotor1,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_2,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_1,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_4,    drawBridgeServo,      tServoStandard)
#pragma config(Servo,  srvo_S2_C3_5,    goalServo,            tServoStandard)
#pragma config(Servo,  srvo_S2_C3_6,    flipperServo,         tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// THIS IS THE MAIN DRIVE CODE - FOR USE IN TELEOP, THIS FILE HAS BEEN CREATED ON Oct 18th, 2014


#include "JoystickDriver.c" // ABSOLUTLY CRUTIAL FOR DRIVING WITH A JOYSTICK
#include "drivers/hitechnic-superpro.h"
#include "drivers/hitechnic-irseeker-v2.h"

// VD - varible declarations

int rev = 1; // 1 = not reversed | -1 means reversed
bool normalctl = true; // normal joystick configuration if true, reverse joystick configuration if false
bool leftmode = true; //leftmode is when up/down is on left and left/right is on right
bool rightmode = false; // rightmode the reverse of leftmode
bool isRunning = false;
bool busyInputingBall = false;
int power = 1; // value to divide joysticks by if needing to drive slower
int quadrent = 0;

int acS1, acS2, acS3, acS4, acS5 = 0;

// values set throughout the program

float leftstickval = 0;
float rightstickval = 0;
float newrightstickval = 0;
int lightSensor = 0;

// global speeds of drive motors
float leftmotorval = 0;
float rightmotorval = 0;

// end of "global" varible declaration

// make sure that the values going to the motor arn't less than -100 or greater than 100
float makesureitsinlimits(float input) {
	if (input > 100) input = 100;
	if (input < -100) input = -100;
	return input;
}

// driving joystick (the one that actually moves the robot's position)
void joyval_joystick1st() { // standard mode on left joystick

	leftstickval = pow(((float)joystick.joy1_y1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_y1 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;

}

// reverse mode on left joystick
void joyval_joystick1rv() {
	leftstickval = pow(((float)joystick.joy1_y2 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_y2 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;
}

// standard mode on right joystick
void joyval_joystick2st() {
	leftstickval = pow(((float)joystick.joy2_y1 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_y1 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy2_x2 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_x2 < 0) rightstickval = rightstickval * -1.0;
}

// reverse mode on right joystick
void joyval_joystick2rv() {
	leftstickval = pow(((float)joystick.joy2_y2 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_y2 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy2_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_x1 < 0) rightstickval = rightstickval * -1.0;
}

//discover the values for use in the driving routine (using above methods)

void joyval_correct() {
	if ((normalctl) & (rev == 1)) {
		joyval_joystick1st();
		} else if ((normalctl) & (rev == -1)) {
		joyval_joystick1rv();
		} else if ((!normalctl) & (rev == 1)) {
		joyval_joystick2st();
		} else if ((!normalctl) & (rev == -1)) {
		joyval_joystick2rv();
		} else {
		PlayImmediateTone(500, 1);
	}
	leftstickval = leftstickval * rev;
	//if (abs(leftstickval) < forwardbackwardthresh) leftstickval = 0;
	rightstickval *= -1.0;
	//if (abs(rightstickval) < leftrightthresh) rightstickval = 0;
}

// returns larger of two numbers
float whichismax(float left, float right) {
	float returnval;
	if (left > right) returnval = left;
	if (right > left) returnval = right;
	if (right == left) returnval = (left + right) / 2;
	return returnval;
}

//MTR - move the motors, where the main drive motors are driven
void movethemotors() {
	motor[leftDriveF] = leftmotorval / power;
	motor[leftDriveR] = leftmotorval / power;

	motor[rightDriveF] = rightmotorval / power;
	motor[rightDriveR] = rightmotorval / power;
	//motor[rightDriveR] = -1;
}

//DJ - where the main driving happens (it calls the other stuff above)
void driving_joystick() {
	if (joy1Btn(9)) { while (joy1Btn(9)) {PlayTone(4000, 1);} rev *= -1;}
	joyval_correct(); //put the correct joystick values in their varibles
	if (leftstickval > 0.0) {
		if (rightstickval > 0.0) {
			quadrent = 1;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = whichismax(leftstickval, rightstickval);
			} else {
			quadrent = 2;
			leftmotorval = whichismax(leftstickval, (rightstickval * -1.0));
			rightmotorval = leftstickval + rightstickval;
		}
		} else {
		if (rightstickval > 0.0) {
			quadrent = 3;
			leftmotorval = (whichismax((leftstickval * -1.0), rightstickval)) * -1.0;
			rightmotorval = leftstickval + rightstickval;
			} else {
			quadrent = 4;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = (whichismax((leftstickval * -1.0), (rightstickval * -1.0))) * -1.0;
		}
	}

	movethemotors();
}

// power control (used for slowing down driving motors to get greater accuracy)

void powercontrol () {
	if (normalctl) {
		if (joy1Btn(1)) power = 1;
		if (joy1Btn(2)) power = 2;
		if (joy1Btn(3)) power = 3;
		if (joy1Btn(4)) power = 4;
		} else {
		if (joy2Btn(1)) power = 1;
		if (joy2Btn(2)) power = 2;
		if (joy2Btn(3)) power = 3;
		if (joy2Btn(4)) power = 4;
	}
}

float withinval(float low, float high, float value) {
	if (value < low) value = low;
	if (value > high) value = high;
	return value;
}

int motorPowerCalc(float target, float current, int stopZone, int holdSpeed, int slowSpeed, int fastSpeed)
{
	int slowZone = 1000;
	int holdingZone = stopZone * 4;
	if (target == current) return 0;
	if (abs(target-current) < stopZone) return 0;
	int retval = fastSpeed; //maximum power
	//if (abs(target - current) < slowZone) retval = 1/90 * (target - current);
	if (abs(target - current) < slowZone) retval = slowSpeed;
	if (abs(target - current) < holdingZone) retval = holdSpeed;
	if (target > current) retval = retval * -1;

	return retval;
}

int flapTrackMotorEncoder, heightEncoder;


bool flapRunning = false;

int flapError = 0;
int flapDistance = -292;

void moveFlapUpOne() {
	if (flapRunning == false) {
		flapRunning = true;
		nMotorEncoder[flapTrackMotor] = flapError * -1;
		nMotorEncoderTarget[flapTrackMotor] = flapDistance;
		motor[flapTrackMotor] = 100;

		while (nMotorRunState[flapTrackMotor] != runStateIdle) {
			//encoderPositionDebugging();
		}
	//	encoderPositionDebugging();
		motor[flapTrackMotor] = 0;
		flapError = flapDistance - nMotorEncoder[flapTrackMotor];
		flapRunning = false;

		//StartTask(waitForFlapMove);
	}
}


task inputBall() {
	busyInputingBall = true;
	servo[flipperServo] = 180;
	wait1Msec(200);
	moveFlapUpOne();
	wait1Msec(200);
	servo[flipperServo] = 90;
	busyInputingBall = false;
}

void encoderPositionDebugging();


int motorLiftPower = 30;
int highGoalPower = 40;
int flipperTarget = 90;
int rollerRolling = 0;
bool rollerButtonStillPressed = false;

int drawBridgeRestingState = 132;

void accessoryControl() {
	if (abs(joystick.joy1_y2) > 5 && !busyInputingBall) {
		motor[flapTrackMotor] = joystick.joy1_y2;
		} else if (joy1Btn(1) && !busyInputingBall) {
		motor[flapTrackMotor] = motorLiftPower;
    } else if (joy1Btn(3) && ! busyInputingBall) {
    motor[flapTrackMotor] = highGoalPower;
		} else if (!busyInputingBall) {
		motor[flapTrackMotor] = 0;

	}
	if (joy1Btn(5)) {

		busyInputingBall = true;
		StartTask(inputBall);
	}
	//if (joy1Btn(6)) {
	//	motor[rollerMotor] = 100;
	//	rollerRolling = 1;
	//	} else if (joy1Btn(8)) {
	//	if (rollerRolling == 1) {
	//		motor[rollerMotor] = 0;
	//		rollerRolling = 0;
	//		rollerButtonStillPressed = true;
	//		} else if (!rollerButtonStillPressed) {
	//		motor[rollerMotor] = -100;
	//		rollerRolling = -1;
	//		} else if (rollerRolling == -1) {
	//		motor[rollerMotor] = 0;
	//		rollerRolling = 0;
	//		} else {
	//		rollerButtonStillPressed = false;
	//	}
	//}

		if (joy1Btn(6)) {
		motor[rollerMotor] = 100;
		rollerButtonStillPressed = false;
		rollerRolling = 1;
		} else if (joy1Btn(8)) {
			motor[rollerMotor] = -100;
			rollerButtonStillPressed = true;
		} else {
			if (rollerButtonStillPressed == true) {
				StartTask(inputBall);\
				rollerButtonStillPressed = false;
			}
			motor[rollerMotor] = 0;

		}



	if (joy1Btn(2) && !busyInputingBall) {
		motor[liftMotor1] = 100;
		motor[liftMotor2] = 100;
		} else if (joy1Btn(4) && !busyInputingBall) {
		motor[liftMotor1] = -100;
		motor[liftMotor2] = -100;
		} else if (!busyInputingBall) {
		motor[liftMotor1] = 0;
		motor[liftMotor2] = 0;
	}

	if (joy1Btn(10)) {
		moveFlapUpOne();
	}


	if (joystick.joy1_TopHat == 4) {
		servo[goalServo] = 250;
		} else if (joystick.joy1_TopHat == 0) {
		servo[goalServo] = 100;
	}
	if (joystick.joy1_TopHat == 2 && !busyInputingBall) {
		servo[flipperServo] = 90;
		} else if (joystick.joy1_TopHat == 6 && !busyInputingBall) {
		servo[flipperServo] = 180;
		} else {
		//servo[servo3] = flipperTarget;
	}

	if (joy1Btn(11)) {
		servo[drawBridgeServo] = 0;
		}	else if (joy1Btn(12)) {
		servo[drawBridgeServo] = 180;
		} else {
		servo[drawBridgeServo] = drawBridgeRestingState;
	}
}


void encoderPositionDebugging() {
	flapTrackMotorEncoder = nMotorEncoder[flapTrackMotor];
	heightEncoder = nMotorEncoder[liftMotor1];
}





void protoboard() {
	lightSensor = HTSPBreadADC(HTSPB, 0, 10);
	if (lightSensor < 20 && !busyInputingBall) {
		busyInputingBall = true;
		StartTask(inputBall);
	}
}

void setupIR() {
	tHTIRS2DSPMode _mode = DSP_1200;
	HTIRS2setDSPMode(HTIRS2, _mode);
}

void readIR() {
	HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5);
}



// BC - battery check
void batterycheck () {
	if (externalBattery == -1) PlayImmediateTone(4000, 1);
}

void runLoopPause() {
	while (time1[T1] < 50) {
		wait1Msec(1);
	}
	time1[T1] = 0;
}



// TMT this is the main thread code
task main() {
	waitForStart();
	setupIR();

	isRunning = true; // sets isRunning to true, just in case it gets set to false

	while (isRunning) {
		getJoystickSettings(joystick);

		driving_joystick();
		accessoryControl();

		encoderPositionDebugging();

		batterycheck();

		//\protoboard();

		readIR();
		//powercontrol();

		runLoopPause();

	}
}
