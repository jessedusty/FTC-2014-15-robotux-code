#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTSPB,          sensorI2CCustom9V)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rollerMotor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     flapTrackMotor, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     leftDriveR,    tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     rightDriveF,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S2_C1_1,     rightDriveR,   tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S2_C1_2,     leftDriveF,    tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S2_C2_1,     liftMotor2,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     liftMotor1,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C3_1,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_2,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S2_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// THIS IS THE MAIN DRIVE CODE - FOR USE IN TELEOP, THIS FILE HAS BEEN CREATED ON Oct 18th, 2014


#include "JoystickDriver.c" // ABSOLUTLY CRUTIAL FOR DRIVING WITH A JOYSTICK

// VD - varible declarations

int rev = 1; // 1 = not reversed | -1 means reversed
bool normalctl = true; // normal joystick configuration if true, reverse joystick configuration if false
bool leftmode = true; //leftmode is when up/down is on left and left/right is on right
bool rightmode = false; // rightmode the reverse of leftmode
bool isRunning = false;
int power = 1; // value to divide joysticks by if needing to drive slower
int quadrent = 0;

// values set throughout the program

float leftstickval = 0;
float rightstickval = 0;
float newrightstickval = 0;

// global speeds of drive motors
float leftmotorval = 0;
float rightmotorval = 0;

// end of "global" varible declaration

// make sure that the values going to the motor arn't less than -100 or greater than 100
float makesureitsinlimits(float input) {
	if (input > 100) input = 100;
	if (input < -100) input = -100;
	return input;
}

// driving joystick (the one that actually moves the robot's position)
void joyval_joystick1st() { // standard mode on left joystick

	leftstickval = pow(((float)joystick.joy1_y1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_y1 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;

}

// reverse mode on left joystick
void joyval_joystick1rv() {
	leftstickval = pow(((float)joystick.joy1_y2 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_y2 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy1_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy1_x1 < 0) rightstickval = rightstickval * -1.0;
}

// standard mode on right joystick
void joyval_joystick2st() {
	leftstickval = pow(((float)joystick.joy2_y1 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_y1 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy2_x2 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_x2 < 0) rightstickval = rightstickval * -1.0;
}

// reverse mode on right joystick
void joyval_joystick2rv() {
	leftstickval = pow(((float)joystick.joy2_y2 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_y2 < 0) leftstickval = leftstickval * -1.0;

	rightstickval = pow(((float)joystick.joy2_x1 / (float)64 * (float)5), 2) ;
	if (joystick.joy2_x1 < 0) rightstickval = rightstickval * -1.0;
}

//discover the values for use in the driving routine (using above methods)

void joyval_correct() {
	if ((normalctl) & (rev == 1)) {
		joyval_joystick1st();
		} else if ((normalctl) & (rev == -1)) {
		joyval_joystick1rv();
		} else if ((!normalctl) & (rev == 1)) {
		joyval_joystick2st();
		} else if ((!normalctl) & (rev == -1)) {
		joyval_joystick2rv();
		} else {
		PlayImmediateTone(500, 1);
	}
	leftstickval = leftstickval * rev;
	//if (abs(leftstickval) < forwardbackwardthresh) leftstickval = 0;
	rightstickval *= -1.0;
	//if (abs(rightstickval) < leftrightthresh) rightstickval = 0;
}

// returns larger of two numbers
float whichismax(float left, float right) {
	float returnval;
	if (left > right) returnval = left;
	if (right > left) returnval = right;
	if (right == left) returnval = (left + right) / 2;
	return returnval;
}

//MTR - move the motors, where the main drive motors are driven
void movethemotors() {
	motor[leftDriveF] = leftmotorval / power;
	motor[leftDriveR] = leftmotorval / power;

	motor[rightDriveF] = rightmotorval / power;
	motor[rightDriveR] = rightmotorval / power;
}

//DJ - where the main driving happens (it calls the other stuff above)
void driving_joystick() {
	if (joy1Btn(9)) { while (joy1Btn(9)) {PlayTone(4000, 1);} rev *= -1;}
	joyval_correct(); //put the correct joystick values in their varibles
	if (leftstickval > 0.0) {
		if (rightstickval > 0.0) {
			quadrent = 1;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = whichismax(leftstickval, rightstickval);
			} else {
			quadrent = 2;
			leftmotorval = whichismax(leftstickval, (rightstickval * -1.0));
			rightmotorval = leftstickval + rightstickval;
		}
		} else {
		if (rightstickval > 0.0) {
			quadrent = 3;
			leftmotorval = (whichismax((leftstickval * -1.0), rightstickval)) * -1.0;
			rightmotorval = leftstickval + rightstickval;
			} else {
			quadrent = 4;
			leftmotorval = leftstickval - rightstickval;
			rightmotorval = (whichismax((leftstickval * -1.0), (rightstickval * -1.0))) * -1.0;
		}
	}

	movethemotors();
}

// power control (used for slowing down driving motors to get greater accuracy)

void powercontrol () {
	if (normalctl) {
		if (joy1Btn(1)) power = 1;
		if (joy1Btn(2)) power = 2;
		if (joy1Btn(3)) power = 3;
		if (joy1Btn(4)) power = 4;
		} else {
		if (joy2Btn(1)) power = 1;
		if (joy2Btn(2)) power = 2;
		if (joy2Btn(3)) power = 3;
		if (joy2Btn(4)) power = 4;
	}
}

float withinval(float low, float high, float value) {
	if (value < low) value = low;
	if (value > high) value = high;
	return value;
}

int motorPowerCalc(float target, float current, int stopZone, int holdSpeed, int slowSpeed, int fastSpeed)
{
	int slowZone = 1000;
	int holdingZone = stopZone * 4;
	if (target == current) return 0;
	if (abs(target-current) < stopZone) return 0;
	int retval = fastSpeed; //maximum power
	//if (abs(target - current) < slowZone) retval = 1/90 * (target - current);
	if (abs(target - current) < slowZone) retval = slowSpeed;
	if (abs(target - current) < holdingZone) retval = holdSpeed;
	if (target > current) retval = retval * -1;

	return retval;
}

#define flapDistance -295;
bool flapRunning = false;

void encoderPositionDebugging();

void moveFlapUpOne() {
	if (flapRunning == false) {
		flapRunning = true;
		nMotorEncoder[flapTrackMotor] = 0;
		nMotorEncoderTarget[flapTrackMotor] = 295;
		motor[flapTrackMotor] = 100;

		while (nMotorRunState[flapTrackMotor] != runStateIdle) {
			encoderPositionDebugging();
		}
		motor[flapTrackMotor] = 0;
		flapRunning = false;

		//StartTask(waitForFlapMove);
	}
}

int motorLiftPower = 30;

void accessoryControl() {
	if (abs(joystick.joy1_y2) > 5) {
		motor[flapTrackMotor] = joystick.joy1_y2;
		} else if (joy1Btn(5)) {
			motor[flapTrackMotor] = 100;
		} else if (joy1Btn(7)) {
			motor[flapTrackMotor] = -100;
		} else if (joy1Btn(1)) {
			motor[flapTrackMotor] = motorLiftPower;
		} else {
			motor[flapTrackMotor] = 0;

	}
	if (joy1Btn(6)) {
		motor[rollerMotor] = 100;
		} else if (joy1Btn(8)) {
		motor[rollerMotor] = -100;
		} else {
		motor[rollerMotor] = 0;
	}

	if (joy1Btn(2)) {
		motor[liftMotor1] = 100;
		motor[liftMotor2] = 100;
	} else if (joy1Btn(4)) {
		motor[liftMotor1] = -100;
		motor[liftMotor2] = -100;
	} else {
		motor[liftMotor1] = 0;
		motor[liftMotor2] = 0;
	}

	if (joy1Btn(9)) {
		moveFlapUpOne();
	}


	if (joystick.joy1_TopHat == 4) {
		servo[servo1] = 10; // Left
		servo[servo2] = 280;
	} else if (joystick.joy1_TopHat == 0) {
		servo[servo1] = 170;
		servo[servo2] = 80;
	}

}

int flapTrackMotorEncoder;
void encoderPositionDebugging() {
	flapTrackMotorEncoder = nMotorEncoder[flapTrackMotor];
}

// BC - battery check
void batterycheck () {
	if (externalBattery == -1) PlayImmediateTone(4000, 1);
}

void runLoopPause() {
	while (time1[T1] < 50) {
		wait1Msec(1);
	}
	time1[T1] = 0;
}



// TMT this is the main thread code
task main() {
//	waitForStart();
	isRunning = true; // sets isRunning to true, just in case it gets set to false

	 while (isRunning) {
		//getJoystickSettings(joystick);

		////driving_joystick();
		//accessoryControl();

		//encoderPositionDebugging();

		batterycheck();

		////powercontrol();



		runLoopPause();
		if (nNxtButtonPressed == 1) {
		motor[liftMotor1] = 100;
		motor[liftMotor2] = 100;
	} else if (nNxtButtonPressed == 2) {
		motor[liftMotor1] = -100;
		motor[liftMotor2] = -100;
	} else {
		motor[liftMotor1] = 0;
		motor[liftMotor2] = 0;
	}


	}
}
